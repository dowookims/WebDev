# Quest 19. Jest & Puppeteer

## TDD (Test Driven Development)

테스트 주도 개발로, 테스트가 개발을 이끌어 나간다는 것이다. 즉, 테스트 코드를 먼저 작성하고 그 테스트를 통과하기 위한 것을 짜는 것을 의미한다.  
추상적으로, 결정과 피드백 사이의 갭에 대한 인식, 더 나아가 결정과 피드백 사이의 갭을 조절하기 위한 테크닉이라고도 한다.

### Pros

* 보다 튼튼한 객체 지향적 코드 생산
* 디버깅 시간 단축
* 재설계 시간 단축
* 테스트 문서의 대체 가능
* 추가 구현 용이
* 코드의 결함이 감소

### Cons

* 생산성의 저하.
* 개발 시간 증가.

### Unit Test

단위 테스트(unit test)는 프로그램의 기본 단위인 모듈을 테스트하여 모듈 테스트(module test)라고도 한다. 전체 애플리케이션에서 떼어 내어 분리된 환경에서 테스트를 진행한다.  
단위테스트는 구현 단계에서 각 모듈의 개발을 완료한 후 개발자가 명세서의 내용대로 정확히 구현되었는지를 테스트한다. 즉 개별 모듈이 제대로 구현되어 정해진 기능을 정확히 수행하는지를 테스트한다. 화이트박스 테스트와 블랙박스 테스트를 모두 사용할 수 있지만 모듈 내부의 구조를 구체적으로 들여다볼 수 있는 화이트박스 테스트 같은 구조적 테스트를 주로 시행한다.

분리하여 테스트를 진행하기 때문에 하나의 모듈이나 클래스에 대해 세밀한 부분까지 테스트 할 수 있고, 더 넓은 범위를 테스트 하는 것 보다 훨씬 빠르게 실행 할 수 있다. 그러나 테스트는 의존성이 있는 모듈을 제어하기 위해 필연적으로 Mocking(모의 객체)를 사용 할 수 밖에 없으며 이 경우 각 모듈이 실제로 잘 연결되어 상호 작용하는지에 대해 검증하지 ㅁㅗㅅ한다. 또한 각 모듈의 사소한 API 변경에도 영향을 받기에 작은 단위의 리팩토링에도 쉽게 깨진다

### Integration Test

단위 테스트가 끝난 모듈을 통합하는 과정에서 발생할 수 있는 오류를 찾는 테스트가 통합 테스트(integration test)이다. 실제 업무에서는 단위 모듈이 개별적으로 존재하는 것이 아니고 여러 모듈이 유기적 관계를 맺고 있으므로 이러한 모듈들을 결합한 형태로 테스트를 수행해봐야 한다. 이때 주로 확인하는 것은 '모듈 간의 상호작용이 정상적으로 수행되는가'이다. 즉 모듈 사이의 인터페이스 오류는 없는지, 모듈이 올바르게 연계되어 동작하고 있는지를 체크한다

모듈 통합을 한꺼번에 하는 방법으로는 빅뱅(big-bang) 테스트를 들 수 있다. 빅뱅 테스트는 단위 테스트가 끝난 모듈을 한꺼번에 결합하여 수행하는 방식이다. 이 방법은 소규모 프로그램이나 프로그램의 일부를 대상으로 하는 경우가 많고 그만큼 절차가 간단하고 쉽다. 그러나 한꺼번에 통합하면 오류가 발생했을 때 어떤 모듈에서 오류가 존재하고 또 그 원인이 무엇인지 찾기가 매우 어렵다.

모듈 통합을 점진적으로 하는 방법은 모듈 통합을 한꺼번에 하는 방법의 문제를 극복하는 방법으로, 완성된 모듈을 기존에 테스트된 모듈과 하나씩 통합하면서 테스트한다. 문제가 발생하면 바로 직전에 통합하여 테스트한 모듈에서 오류가 발생했다고 짐작할 수 있으므로 오류를 찾기가 쉽다. 점진적 통합 방식은 가장 상위에 있는 모듈부터 테스트하는지, 가장 하위에 있는 모듈부터 테스트하는지에 따라 하향식 기법과 상향식 기법으로 나뉜다.

### E2E test ( End to End Test)

기능 테스트라고 불리는 테스팅 기법으로, 끝에서 끝까지 테스트한다. 사용자가 직접 애플리케이션을 사용하는 것처럼 동작하도록 스크립트를 작성하고 이것을 실제 실행시켜보면서 기대한대로 동작하는지 검증한다.

사용자 관점에서 테스트를 진행하며, 사용자가 움직일거라 예상하는 시나리오를 매크로 처럼 스크립트를 작성해서 브라우저 내에서 자동으로 실행하여 테스트를 진행한다.

사용자의 실행 환경과 거의 동일한 환경에서 테스트를 진행하기 때문에 실제 상황에서 발생할 수 있는 에러를 사전에 발견할 수 있다는 장점이 있다. 특히 브라우저를 외부에서 직접 제어할 수 있어 자바스크립트의 API만으로는 제어할 수 없는 행위(브라우저 크기 변경, 실제 키보드 입력 등)를 테스트할 수도 있다. 또한 테스트 코드가 실제 코드 내부 구조에 영향을 받지 않기 때문에 큰 범위의 리팩토링에도 깨지지 않는다.

단위 테스트나 통합 테스트에 비해 테스트의 실행 속도가 느리기 때문에 개발 단계에서 빠른 피드백을 받기가 어려우며, 세부 모듈들이 갖는 다양한 상황들의 조합을 고려해야 하기 때문에 테스트를 작성하기가 쉽지 않다는 단점이 있다. 또한 큰 단위의 기능을 작은 기능으로 나누어 테스트할 수가 없기 때문에 필연적으로 테스트 사이에 중복이 발생할 수밖에 없다. 게다가 통제된 샌드박스 환경에서의 테스트가 아니기 때문에 테스트 실행 환경의 예상하지 못한 문제들(네트워크 오류, 프로세스 대기로 인한 타임아웃 등)로 인해 테스트가 가끔 실패하는 일이 발생하며, 이 때문에 테스트를 100% 신뢰할 수 없는 문제가 발생하기도 한다.

### Testing Tool

자바스크립트에서 테스트 도구로써 테스트를 구동할 수 있는 환경을 제공하는 **테스트 러너**와 테스트 코드 작성을 위한 기반을 만들어 주는 **테스트 프레임워크**로 나뉜다. 이 외에 테스트 코드를 좀더 편리하게 작성할 수 있도록 도와주는 **assertion library**와 **test double library** 가 존재한다.

#### Test Runner

테스트 파일을 읽어들여 작성한 코드를 실행하고, 결과를 특정한 형식으로 출력해준다. 테스트의 수행 결과는 리포터(Reporter)를 지정해서 원하는 형태로 출력할 수 있다. 부가적으로 테스트 코드나 소스 코드가 변경된 경우 영향을 받는 테스트를 자동으로 재실행해주는 왓쳐(Watcher) 등의 기능도 제공한다.

이전에는 자바스크립트를 실행할 수 있는 환경이 브라우저에 한정되어 있었기 때문에, 작성된 테스트 코드를 직접 브라우저에서 실행한 후 웹페이지나 브라우저 콘솔을 통해서만 결과를 확인할 수 있었다. 하지만 Node.js의 등장으로 브라우저 없이도 자바스크립트 코드를 손쉽게 실행할 수 있게 되었으며, 덕분에 테스트 러너와 같은 도구를 사용해 이러한 과정을 자동화할 수 있게 되었다.

테스트 러너는 크게 **Karma**와 같이 브라우저에서 직접 코드를 실행하는 러너와, **Jest**와 같이 Node.js 환경에서 코드를 실행하는 러너로 나눌 수 있다. 이 중 Node.js 기반의 테스트 러너들은 굳이 러너의 실행 환경과 코드의 실행 환경을 구분할 필요가 없기 때문에 대부분 테스트 프레임워크와 통합된 형태로 제공된다.

#### Test Framework

사용자가 테스트 코드를 작성할 수 있는 기반을 제공해주는 자바스크립트 도구이다. 프레임워크가 제공하는 함수들을 사용해서 테스트 코드를 작성하면, 프레임워크가 테스트 코드를 자동으로 실행한 후 성공 및 실패에 대한 결과를 반환해준다.

#### Test Double

실제 객체 대신 테스트를 위해 동작하는 객체를 말하며, 주로 분리된(isloated) 단위 테스트를 위해 외부 의존성을 임의로 주입하기 위해서 사용한다. 필요에 따라 스파이(spy), 스텁(stub), 목(mock) 등의 다양한 테스트 더블을 사용할 수 있으며, 이들을 쉽게 만들 수 있도록 도와주는 라이브러리를 테스트 더블 라이브러리라고 한다. 단언과 마찬가지로 테스트 더블을 위한 함수들도 테스트 프레임워크에서 기본 제공되는 경우가 대부분이며, Mocha의 경우에만 Sinon.JS 등의 별도 라이브러리를 사용하도록 권장하고 있다.

테스트 더블은 일반적으로 자바스크립트 객체 혹은 함수를 직접 변경하거나 생성하는 형태로 사용되며, Jest에서는 모듈 단위로 사용할 수 있는 기능도 제공한다. 또한 Jasmine의 Clock이나 Sinon.JS의 Lolex와 같은 도구를 사용하면 자바스크립트의 타이머 API도 직접 제어하며 테스트할 수 있다.

[테스트](https://ui.toast.com/fe-guide/ko_TEST/)

### Stub & Mock

#### Stub

* 객첵가 마치 실제로 동작하는 것 처럼 보이게 만들어 놓은 객체이다.
* 객체의 특정 상태를 가정하여 특정 값을 리턴해 주거나 특정 메시지를 출력해 주는 작업을 한다.
* 특정 상태를 가정해서 하드코딩된 형태이므로 로직에 따른 값의 변경은 테스트 할 수 없다.
* 어떤 행위(method)가 호출됐을 때 특정 값으로 리턴시켜주는 형태를 Stub이라 한다.
* 상태를 검증하는데 사용된다.

#### Mock

* 단위 테스트를 하기 위해 메서드를 실행하는데, 메서드가 네트워크 또는 데이터베이스 등 비동기에 의존하고 있을 때 단위 테스트를 하기 어렵다. 이 문제를 해결하기 위해 등장한 개념이 `Mock`이다.  

* Mock은 실제 객체를 만들기엔 비용과 시간이 많이 들거나 의존성이 길게 걸쳐져 있어 제대로 구현하기 어려울 경우, 가짜 객체를 만드는데 이 때 각자 객체를 Mock 이라 부른다.

* 테스트 작성을 위한 환경 구축이 어려운 경우에 사용된다.

* 테스트가 특정 경우나 순간에 의존적인 경우에 사용된다.

* Mock은 행위를 검증 할 때 주로 사용된다.

#### Test spy

* 테스트에 사용되는 객체, 메소드의 사용 여부 및 정상 호출 여부를 기록하고 요청시 알려준다.

#### Dummy Object

인스턴스화 될 수 있는 수준으로써의 객체로, 인스턴스화된 객체가 필요할 뿐 해당 객체의 기능까지 필요하지 않은 경우에 사용한다.

행위를 검증한다.

## Jest

### Javascript test framework

* Mocha

Test Runnerr를 포함한 테스트 프레임워크로 자체적으로 Assertion을 제공하지 않기 때문에 다른 Assertion라이브러리와 함께 사용한다. 주로 `chai`와 함께 사용되며, BDD기반의 테스트 프레임 워크이다.

* Jest

Jest는 페이스북에서 만든 오픈소스 테스트 프레임워크이며, 최근 프론트엔드 개발에서 가장 활발하게 사용되는 테스트 도구이다. 꽤 오랜 기간 동안 개발되어 왔음에도 불구하고 한동안 관심을 받지 못하다가, 최근에 안정성 및 성능이 눈에 띄게 좋아지면서 많은 인기를 끌고 있다. Karma와는 다르게 Node.js 환경에서 실행되며, 내부적으로 Jasmine 스타일의 단언 API를 사용하기 때문에 기존에 Jasmine을 사용하고 있던 사용자들도 쉽게 적응할 수 있다.

Jest의 가장 큰 장점은 쉬운 설치 및 사용 방법이라 할 수 있다. Jest는 테스트 러너의 기능뿐 아니라, 단언, 테스트 더블, 코드 커버리지 등 테스트에 필요한 모든 기능을 지원하기 때문에 별다른 추가 설치가 필요 없다. 또한 특별한 설정 없이 디폴트 설정 만으로도 실행할 수 있기 때문에, 처음 사용하는 사람도 손쉽게 테스트를 작성하고 실행해 볼 수 있다.

또한, 테스트 파일이 `*.spec.js` 형식을 따른다면 추가 설정이 필요 없이 바로 실행할 수 있다.

## Puppeteer

Puppeteer는 Headless Chrome, Chronium을 제어하도록 도와주는 라이브러리이다. 이는

* SPA 렌더링을 가능하게 하며
* 렌더링 후 키보드, 마우스 입력을 제어 할 수 있게하고
* 웹페이지의 자동 테스트 도구를 가능하게 하며
* 각깍의 웹페이지 crawling이 가능하고
* 접속한 페이지를 snap shot 하여 pdf로 만들 수 있다.

[Puppeteer 간단정리](https://medium.com/@pks2974/puppeteer-%EA%B0%84%EB%8B%A8-%EC%A0%95%EB%A6%AC%ED%95%98%EA%B8%B0-a252bffbb2a8)
