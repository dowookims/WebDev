# Quest 12. AJAX(Asynchronous Javascript And XML)

## 어떠한 자바스크립트 코드가 HTTP 응답이나 사용자의 이벤트등에 종속되어 언제 실행되어야 할 지 알기 어려울 때엔 어떻게 해야 할까요?

HTTP응답은 네트워크의 속도와 request의 수신 및 처리, request에 대한 비즈니스 로직 및 서버 내 로직, 이에 대한 응답등으로 인해 언제 클라이언트의 요청에 대한 응답을 받을 수 없다.

사용자의 이벤트에 종속되어 있는 경우, 클라이언트를 구축 할 때 이벤트 리스너 등을 통해 특정 이벤트에 그에 맞는 반응을 등록 해 두고, 사용자가 그 이벤트를 점화 했을 때만 자바스크립트 코드들이 실행되기 때문에 그 시점에 대해 예측한다는 것은 거의 불가능 하다고 볼 수 있다.

그렇기에 자바스크립트는 이 시점을 정확히 예측하기 보다는, 네트워크 및 사용자의 행위에 대해 이벤트를 등록(callback 을 통해) 해 두고, 그 이벤트들이 점화 될 때 특정한 요청들을 처리하는 방식으로 문제를 해결한다.

자바스크립트의 경우 싱글 스레드 기반 언어이기 때문에, 이런 네트워크와 관련된 요청을 동기적으로 작업하게 되면, 즉시 처리되는 요청같은 경우는 사용자에게 불편함을 주지 않지만 그렇지 않은 경우 클라이언트에서 작업을 처리하기 위해 다른 작업이 중단 될 수 있다. 

그래서 브라우저 에서는 이런 작업들을 처리하기 위한 몇가지 장치들이 존재하는데, 이 때 사용되는 장치들이 이벤트 루프와 태스크 큐 등이 있다.

V8과 같은 자바스크립트 엔진은 단일 호출 스택(Call Stack)을 사용하며, 요청이 들어 올 때마다 해당 요청을 순차적으로 호출 스택에 담아 처리한다. 단일 호출 스택을 사용하며, pop을 통해 호출 스택에 있는 요청을 처리한다면 비동기 요청 및 동시성에 대한 처리는 불가능 해 진다. 그러나 자바스크립트 엔진들은 이 문제들을 해결 해내는데, 이는 바로 자바스크립트 엔진을 구동하는 환경인 브라우저나 Node.js가 담당한다.

![javascript env](https://image.toast.com/aaaadh/real/2018/techblog/b1493856379d11e69c16a9a4cf841567.png)

* 비동기 호출을 위해 사용하는 `setTimeOut`이나 `XMLHttpRequest` 함수들은 JS Engine이 아닌 Web  API 영역에 따로 저장되어 있다.
* 이벤트 루프나 태스크 큐와 같은 장치도 JS Engine 외부에 구현되어 있다.

![Node js Env](https://image.toast.com/aaaadh/real/2018/techblog/Bt5ywJrIEAAKJQt.jpg)

[ 참고자료 - Toast meet up 김동우님 자료](https://meetup.toast.com/posts/89)

* Node.js는 비동기 IO를 지원하기 위해 libuv 라이브러리를 사용하며, 이 라이브러리가 이벤트 루프를 제공한다.
* JS 엔진은 비동기 작업을 위해 Node.js의 API를 호출하고, 이 때 넘겨진 `callback`은 libuv의 이벤트 루프를 통해 스케쥴되고 실행된다.

여기서 핵심은, 자바스크립트가 `싱글 스레드 기반의 언어` 라는 것은 자바스크립트 엔진이 단일 호출 스택을 사용한다는 관점에서만 사실이다. 실제 자바스크립트가 구동되는 환경(Node.js, Browser)의 경우 여러 개의 스레드가 사용되며, 구동 환경이 단일 호출 스택을 사용하는 JS 엔진과 상호 연동하기 위해 사용하는 장치가 `Event Loop`이다.

개발자가 `setTimeout`이나, `XMLHttpRequest`, `fetch`등을 사용하여 비동기 요청을 처리하는 로직을 짰다고 가정하자. 여기서 자바스크립트를 해석하면서, 이를 실행할 때, 순차적으로 콜스택에 담기게 되고, 실행된다. 실행된 함수 들 중 `setTimeout`, `XMLHttpRequest` 함수 같은 경우 브라우저에게 타이머, AJAX 이벤트를 요청한 후 바로 스택에서 제거 된다. 이 때, 함수에 포함된 콜백 함수들은 즉시 사라지지 않고 `Task Queue`라는, 콜백 함수들이 대기하는 큐 형태의 배열에 들어가게 된다. 그리고 이벤트 루프는 호출 스택이 비워질 때마다 큐에서 콜백 함수를 꺼내와서 실행하는 역할을 한다.

```js
// why event loop?
while(queue.waitForMessage()){
  queue.processNextMessage();
}
```

위 코드의 `waitForMessage()` 메소드는 현재 실행중인 태스크가 없을 때, 다음 태스크가 큐에 추가될 때 까지 대기하는 역할을 한다. 이렇게 이벤트 루프는 `현재 실행중인 태스크가 없는지` 와 `태스크 큐에 태스크가 있는지`를 반복적으로 확인한다. 이를 정리하자면

* 모든 비동기 API들은 작업이 완료되면 콜백 함수를 태스크 큐에 추가한다
* 이벤트 루프는 현재 실행중인 태스크가 없을 때(콜 스택이 비워졌을 때) 태스크 큐의 첫 번째 태스크를 꺼내와 실행한다.

자바스크립트의 비동기 함수들은 이벤트 루프를 통해 콜백 함수를 실행한다. 그렇기에 에러 처리 관련 코드들도 조금은 다르게 동작하는데,

```js
document.querySelector('.btn').click(() => {
    try {
        $.getJSON('/api/members', (res) => {
            // 에러 발생 코드
        })
    } catch (e) {
        console.log(`Error : ${e.message}`)
    };
});
```

위의 코드에서, 버튼이 클릭되어 콜백 A가 실행될 때, `$.getJSON` 함수는 브라우저의 `XMLHttpRequest` API를 통해 서버로 비동기 요청을 보낸 후 바로 실행을 마치고 호출 스택에서 제거된다.

이후, 서버에서 응답을 받은 브라우저는 콜백을 태스크 큐에 추가하고, 콜백은 이벤트 루프에 의해 실행되어 호출 스택에 추가된다. 그러나 클릭 이벤트 콜백은 이미 호출 스택에서 비워진 상태이므로 호출 스택에는 응답에 대한 콜백만 가지고 있다. 즉, 실행될 때 전혀 다른 독립적인 컨텍스트에서 실행되기 때문에 클릭 이벤트 내부의 try-catch 문의 영향을 받지 않는다.

이런 이유로 Node.js의 비동기 API들은 중첩된 콜백 호출에 대한 에러 처리를 위해 첫 번째 인수는 에러 콜백 함수라는 컨벤션을 따르고 있다.

이 문제를 해결하기 위해, 요청에 대한 응답 콜백에 try-catch를 실행해야 하며, 이렇게 해도 네트워크 에러나 서버 에러는 잡을 수 없기에 이를 위해 에러 콜백을 따로 제공해야 한다.

```js
document.querySelector('.btn').click(() => {
    $.getJSON('/api/members', (res) => {
        try {

        } catch (e) {
            console.log(`Error : ${e.message}`);
        }
    });
});
```

프론트 엔드 환경에서는, 콜백 함수의 실행 순서를 조절하기 위해 `setTimeout(fn, 0)`과 같은 코드를 종종보게 된다. setTimeout 함수는 콜백 함수를 바로 실행하지 않고, 태스크 큐에 추가 후 실행하게 실행 플로우를 변경시키기 때문에 이를 기반으로 다양한 처리를 할 수 있다. 특히 렌더링 엔진과 관련하여 작업을 처리 할 때 용이하게 쓰인다.

```js
document.querySelector('.btn').click(()  => {
    showWaitingMessage();
    longTakingProcess();
    hideWaitingMessage();
    showResult();
});
```

`longTakingProcess`가 오래 걸리는 작업이기에 그 전에 `showWaitingMessage`를 호출해서 로딩중 이라는 메시지를 보여주려고 할 때, 이 메시지가 표시될 일은 없다. showWaitingMessage() 함수의 실행이 끝나고 렌더링 엔진이 렌더링 요청을 보내도 해당 요청은 task queue에서 이미 실행중인 태스크가 끝나기를 기다리고 있기 때문이다.

실행중인 태스크가 끝나는 시점은 호출 스택이 비워지는 시점인데, 그 때는 `showResult()` 까지 실행이 끝나 있을 것이고, 결국 렌더링 되는 시점에서 `hideWaitingMessage`로 인해 로딩 메시지가 숨겨질 상태 일 것이다. 이를 위해 `setTimeout`을 사용하기도 한다.

```js
document.querySelector('.btn').click(() => {
    showWaitingMessage();
    setTimeout(() => {
        longTakingProcess();
        hideWaitingMessage();
        showResult();
    }, 0);
});
```

이 경우, `longTakingProcess`가 바로 실행되지 않고 태스크 큐에 추가 될 것이다. 그러나 `showWaitingMessage`로 인해 태스크 큐에는 렌더링 요청이 먼저 추가되기에 `longTakingProcess`는 그 다음 순서로 태스크 큐에 추가될 것이다. 이로 인해 이벤트 루프는 태스크 큐에 있는 렌더링 요청을 먼저 처리하게 되고, 로딩 메시지가 먼저 화면에 보여지게 된다.

렌더링 관련된 문제 뿐만 아니라, 실행이 오래 걸리는 코드를 `setTimeout`을 사용하여 적절하게 다른 태스크로 나누어 주는 것은 전체 어플리케이션이 멈추는 것을 방지해준다.

## 브라우저의 XMLHttpRequest 객체는 무엇이고 어떻게 동작하나요?

## fetch API는 무엇이고 어떻게 동작하나요?

### 자바스크립트의 Promise는 어떤 객체이고 어떤 일을 하나요?

### 자바스크립트의 async와 await 키워드는 어떤 역할을 하며 그 정체는 무엇일까요?
