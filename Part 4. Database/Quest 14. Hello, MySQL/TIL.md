# Quest 14. Hello, MySQL

## 1. What is RDBMS

### 1.0 What is Database

일반적으로 컴퓨터 시스템 내 전자 방식으로 저장된 구조화된 정보 또는 데이터의 조직적 집합을 의미한다. 데이터 베이스는 데이터베이스 관리 시스템 (DBMS)에 의해 제어되며, 데이터와 DBMS는 연관된 어플리케이션과 함께 `데이터 베이스 시스템` 또는 `데이터베이스`라고 통칭된다.

현재 운용되는 가장 공통적인 유형의 데이터베이스(관계형 데이터 베이스, RDBMS) 내에 데이터는 일련의 표 안에 행과 열로 모델링 되는데 이는 프로세싱과 데이터 쿼리 작업을 더 효율적으로 실행하기 위함이다. 이로써 데이터는 쉽게 액세스, 관리, 수정, 업데이트, 제어, 체계화 될 수 있다. 대부분의 데이터베이스는 데이터 작성 및 쿼리 작업을 위해 SQL을 사용한다.

### 1.1 Why Use DataBase

* 대량의 데이터 중에서 필요한 것을 빨리 반환할 수 있다.
  * 데이터 베이스는 효율적으로 데이터 구조를 관리하는 것을 목적으로 한다.
  * 대량의 데이터에서 효율적인 탐색을 위해 검색 알고리즘 및 인덱스와 같은 데이터 구조로 레코드를 관리한다.
  
* 데이터를 안전하게 저장하기 위해 필요하다
  * 인메모리 데이터는 휘발성이 강하여, 빠른접근은 가능하지만 오류시 복구에 큰 차질을 빚는다.
  * 검색 뿐만 아니라 저장, 복구, 보안등을 효율적으로 관리 할 수 있게 한다.

* 병렬성 제어를 용이하게 해준다.
  * 배타 제어의 범위를 손쉽게 설정 할 수 있다.
  * 상호 배제를 하는데 용이하다.

* 데이터의 무결성을 보장한다.
  * 제약 조건 및 영속성 있는 ID 부여 및 다양한 방법으로 데이터의 무결성을 보장한다.

### 1.2 What is MySQL

세계에서 가장 많이 쓰이는 오픈 소스의 관계형 데이터베이스 관리 시스템(RDBMS)이다.  
다중 스레드, 다중 사용자 형식의 구조질의어 형식의 데이터베이스 관리 시스템으로서 오라클이 관리 및 지원하고 있으며 이중 라이선스가 적용된다.

#### 1.2.1 MySQL Engines

데이터 베이스를 어떻게 구현하여 사용 할 지는 데이터 베이스의 용도에 따라 달라진다. MySQL에서는 다양한 레코드 처리 방법을 제공하고 있기에 용도에 맞는 것을 선택할 수 있는 아키텍처를 채용하고 있다. 이것들을 스토리지 엔진이라고 한다.  
 스토리지 엔진의 선택은 테이블 단위로 할 수 있다. 따라서 어플리케이션에서 여러 스토리지 엔진을 혼합할 수 있다.

##### InnoDB

InnoDB는 높은 신뢰성과 고성능 사이의 밸런스를 가지고 있는 범용 스토리지 엔진이다.
MySQL 8.0 버전에서 MyISAM 을 제치고 MySQL 테이블의 default type으로 지정되었다.

InnoDB 테이블은 Primary key를 기반으로 쿼리를 최적화하기 위해 디스크의 데이터를 할당한다. 각 InnoDB 테이블에는 데이터를 정리하여 Primary Key 조회를 위한 I/O를 최소화하는 clustered index라는 primary key index가 있다.

* Transactional-safe (ACID)

  * Atomicity  
    트랜잭션 작업이 부분적으로 실행되거나 중단되지 않는 것을 보장 (All or Nothing)
  * Consistency  
    트랜잭션 작업이 시작되지 전에 데이터베이스 상태가 일관된 상태였다면 트랜잭션 작업이 종료된 후에도 일관성 있는 데이터 베이스 상태를 유지해아한다.
  * Isolation  
    트랜잭션 작업 수행 중에는 다른 트랜잭션에 영향을 주어서도 안되고, 다른 트랜잭션들에 의해 간섭을 받아서도 안 된다
  * Durability  
    일련의 데이터 조작(트렌젝션 조작)을 완료 하고 완료 통지를 사용자가 받는 시점에서 그 조작이 영구적이 되어 그 결과를 잃지 않는 것을 나타낸다  
    commit, rollback, recovery, row-level locking, foreign key를 지원한다.

* 제약조건, FK, PK 등으로 인해 데이터 무결성에 대한 보장이 된다.
* row level lock(행 단위)을 하기에, 쓰기, 변경 작업이 빠르다.
* 데이터 모델 디자인에 많은 시간이 필요하다.
* Full text search를 지원한다.
* ordering 가능

##### MyISAM

* non-transactional-safe 테이블을 관리한다.
* non-acid compliant
* 데이터 무결성이 보장되지 않는다.
* Full text index를 통한 search를 지원한다.
* Table level lock을 사용하기에 쓰기 작업에서 속도가 느리다.
* 읽기 위주 작업에 주로 사용된다.
* 한번에 대량의 데이터를 입력하는 배치성 테이블에 적합하다.

##### Memory

* Memory storage engine (known as HEAP)은 콘텐츠들을 메모리에 저장하는 특수 목적의 테이블을 생성한다. 이 테이블은 임시 작업 영역 또는 다른 테이블에서 가져온 데이터의 읽기 전용 캐시로만 사용한다.

##### CSV

* comma-separated values format을 사용하는 텍스트 파일을 저장할 때 사용하는 스토리지 엔진.

##### Archive

* 인덱싱되지 않은 대량의 데이터를 매우 작은 공간에 저장하는 특수 목적 테이블을 생성한다.

##### Etc

* Merge
* Blackhole
* Federated

#### 1.2.2 MySQL Data Type

##### 문자열

* CHAR : `CHAR(n)` 으로 스트링 데이터 타입을 지정 할 수 있다.  
`n <= 65535`  
`n`만큼의 메모리를 지정하기 때문에, 이 데이터 타입을 쓰는 변수가 n 만큼의 크기를 갖지 않더라도 공백으로 빈 칸을 채운다.  
해당 변수의 크기를 줄이는 작업이 없기 때문에 varchar보다 오버헤드가 적게든다.

* VARCHAR : VARiable length CHARacter string으로, `varchar(n)`로 스트링 데이터 타입을 지정 할 수 있다.  
`n <= 255`  
`char`와 다르게, 지정한 크기보다 작은 string의 경우 할당된 n만큼 값을 차지하는게 아니라, 그 string의 크기 만큼 메모리를 차지한다. 그렇기에 char보다 overhead를 더 사용한다.

* TEXT : 필드의 기본 값(default)를 가질 수 없으며, TEXT를 인덱싱 할 때 `n`을 정의하는데, 이 `n`은 처음 `n`개의 문자만 인덱스 할 수 있음을 의미한다. 그렇기에, 필드 전체를 검색하는 로직이 있는 경우 `TEXT` 타입보다 `CHAR` 또는 `VARCHAR`를 사용하는게 더 나으며, 필드 앞에 몇 개의 글자만 검색하는 경우에는 `TEXT`를 사용하는 것도 좋다.

  * TINYTEXT(n) : 최대 n (<= 255)
  * TEXT(n) : 최대 n (<= 65535)
  * MEDIUMTEXT(n) : 최대 n (<= 16777215)
  * LONGTEXT(n) : 최대 n (<= 4294967295)

```text
특정 텍스트 값이 저장 될 때, 그 해당 데이터의 텍스트 길이의 유동 폭이 크고, 메모리 관리가 중요 할 경우  
varchar를 쓰는게 더 효율적이고, 텍스트 길이의 유동 폭이 적고, 빠른 읽기 작업이 필요 할 경우 char를 쓰는게 더 나은 사용이다.
```

##### Binary 형

* BINARY : `BINARY(n)` 일반 텍스트와 관련 없는 문자의 전체 바이트를 저장하는데 사용한다.  
GIF와 같은 이미지를 저장하는데 사용되기도 하며, `n <= 255` 이다.

* VARBINARY : `BINARY`의 variable length를 가질 수 있는 값으로 최대 `n <= 65535` 크기의 값을 가질 수 있다.

* BLOB : Binary Large Object. 크기가 65535 바이트를 넘는 바이너리 데이터에 가장 유용하며, `BINARY`와 다른점은 기본 값을 가질 수 없다는 것이다.
  * TINYBLOB(n) : 최대 n (<= 255)
  * BLOB(n) : 최대 n (<= 65535)
  * MEDIUMBLOB(n) : 최대 n (<= 16777215)
  * LONGBLOB(n) : 최대 n (<= 4294967295)

##### 숫자형

float을 제외한 모든 수는 `signed`와 `unsigned`를 가지고 있다.
| datatype | byte | min value(signed / unsigned) | max value(signed / unsgined) |
|----------|------|------------------------------|------------------------------|
| TINYINT  |  1   | -128 / 0 | 127 / 255 |
| SMALLINT | 2 | -32768 / 0 | 32767 / 65535 |
| MEDIUMINT | 3 | -8388608 / 0 | 8388607 / 16777215 |
| INT(INTEGER) | 4 | -2^31 / 0 | 2^31 -1 / 2^32-1 |
| BIGINT | 8 | -2^63 / 0 | 2^63 + 1 / 2^64 - 1 |
| FLOAT | 4 | 3.4E-38(-3.4*10^38) ~ 3.4E+38(3.4*10^38) |
| DOUBLE(REAL) | 8 | 1.79E-308(-1.79*10^308) ~ 1.79E+308(1.79*10^308) |

### 1.3 What is Indexing

데이터 베이스에서 원하는 데이터를 검색하기 위해서 완전 탐색을 진행하게 되면 O(N) 의 복잡도를 가진다.  
이런 선형 검색의 경우 데이터 베이스 테이블의 자료수에 영향을 받기 때문에 이보다 더 효율적인 알고리즘으로 검색을 처리해야 할 필요성이 있다. 이 때 사용되는 것이 Index 이다.

인덱스는 각각의 인덱스마다 파일 상의 시작 위치를 기록한 파일을 만듬으로써 고속으로 검색을 가능하게 한다.  
인덱스 항목이 (key, byte location) 일 경우, 고정 길이 포맷으로 대응할 수 있는데, 이는 특정한 로직으로 이를 고정 포맷으로 적용하게 만드는 것이다.  

#### 1.3.1 Hash

실제 데이터베이스의 구현에서 키 값을 그대로 관리하는 게 아니라, 키 값을 해쉬 함수에 대입 해, 해쉬 값과 값의 쌍을 갖는 구조가 자주 사용되고 있다. 이런 인덱스를 `Hash Index`라고 한다.

해시 값은 문자열 길이에 상관없이 동일한 크기이므로 고정 길이 포맷으로 대응 할 수 있으며, 해시 계산 비용도 데이터 양에 의존하지 않기에 데이터 양이 늘어도 계산량은 변경되지 않는다.

데이터량이 많아지다보면 해시함수는 해시값의 개수보다 많은 키 값을 해시값으로 변환 하게 되고, 해시함수가 서로 다른 두개의 키에 동일한 해시 값을 내는 `해시 충돌(collision)`이 발생할 수 있다.

또한 해시는 하나의 항목을 검색하는데 효율적이나, 범위 검색을 통한 대량의 데이터 반환 및 소팅에 큰 도움이 되지 않는다. 이를 해결하기 위해 `B+ Tree` Index가 존재한다.

#### 1.3.2 B+ Tree

`Root` + `Branches` + `Leaf`로 이루어진 Tree구조로 된 Index.

데이터 검색을 위해 `Root` => `Branch` => `Leaf` 순으로 이동하여 조회한다.

* 레코드 수가 적으면 `Root`가 `Branch`를 겸하며, `Root`와 `Leaf` 밖에 없는 패턴도 존재한다.

* 레코드 수가 많으면  브랜치 아래 브랜치가 들어가는 계층 구조가 구성될 것이다.

`이진 트리`의 경우 레코드 수당 탐색에 필요한 복잡도가 밑이 2인 로그 함수를 따른다. 그러나 B+ Tree의 경우 분기를 M개로 하여 액세스 횟수를 적게 함으로, 밑이 m인 로그 함수를 구현함으로써 더 효율적으로 동작 할 수 있다.

## 2. SQL Query

### 2.1 Create

```SQL
INSERT INTO <tablename> (column1,column2,….)
 
VALUES (value1_1,value1_2,….),
(value2_1, value2_2, ...)
...
(value_n_1, valuen_2, ...);
```

### 2.2 Read

```SQL
SELECT (column1, column2 ,...) FROM <TableName>
```

```SQL
SELECT * FROM <TableName>
```

### 2.3 Update

```SQL
UPDATE <TableName>
SET Column1=Value1, Column2=Value2,…
WHERE <Expression>
```

### 2.4 Delete

```SQL
DELETE FROM <TableName>
WHERE <Expression>
```

## 3. Hashing

`Hashing`은 파일에서 고정 크기 비트 문자열 값을 계산하는 알고리즘이다. 파일은 기본적으로 데이터 블록을 포함한다. Hashing은 이 데이터를 원래의 문자열을 나타내는 훨씬 짧은 고정 길이 값 또는 키로 변환한다. 해시 값은 해당 파일 내의 모든 것을 증류한 요약본으로 간주할 수 있다.

Hashing이란 기존 값에 수학적 공식을 도입하여 값을 |0-9|, |a-f|로 변환하여 난독화 하게 만드는 것을 의미한다.  
난독화 하는 방법들은 다양한데, 이 방법을 Hash Function이라 하며, Hash function에는 다양한 종류가 존재한다.

해시 함수의 특징으로, 같은 입력값이라면 같은 출력 값을 보장한다는 것이다. 이는 결정론적 알고리즘이라고도 한다.

Hashing을 하는 이유는 다양하다. 보안되어야 할 값을 난독화 하기도 하고, 어떤 변화가 일어 났을 때 그 변화를 손쉽게 파악하기도 하며, 두 파일이 같은지 검사하는 등 다양한 범위에서 사용된다.

*salt* : `rainbow table`에 특정 값들을 저장해 놓고, 관련된 해시를 저장해 두면 보안상 문제가 발생한다. 그렇기에 기존 값에 `salt`라는 값을 추가하여 해커들 또는 `rainbow table`에서 저장 한 값과 다른 값을 도출해 내어 해쉬 함수의 보안을 더 강화하는 값이다.

### 3.1 Hashing Algorithm

SHA-256의 경우 해시 대상 메시지를 전처리하는 단계와 전처리된 메시지를 바탕으로 해시를 계산하는 단계로 나뉜다.

#### 메시지 전처리

SHA-256을 적용해야 할 데이터를 `메시지`라고 한다. 이때 메시지 bit의 길이가 512 배수가 되도록 padding을 추가하는 것이 전처리 단계에서 수행하는 작업이다.

1. 원본 메시지의 바로 뒤에 비트 '1'을 추가한다.
2. 메시지의 길이가 512의 배수가 되도록 메시지에 0을 추가한다.
3. 메시지의 마지막 64bit에는 원본 메시지의 bit 길이를 적는다.

#### 전처리된 메시지 해싱

메시지 전처리가 끝나면 메시지의 bit 길이는 512의 배수 형태가 된다. 이 전처리된 메시지를 512bit 단위로 쪼개어 여러개의 chunk를 만들고, 이 chunk를 순회하며 특정 연산을 수행하여 최종적인 hash값을 계산해 낸다.

[SHA-256구현](https://www.secmem.org/blog/2019/07/21/sha256/)

### 3.2 Types of Hash

#### MD5 (Message Digest Algorithm 5)

128bit 암호화 해시 함수이며, RFC 1321로 지정되었으며 프로그램이나 파일이 원본 그대로인지 확인하는 무결성 검사 등에 사용된다. MD5의 설계상 결함과 `Rainbow Table`에 의해 쉽게 뚫리고, `hash collision`의 발생등으로 인해 보안 관련 용도로 사용하는 것은 권장되지 않는다.

* 32개의 문자(16진수 - 4비트) 로 해쉬 결과의 길이가 128 비트이다.

#### SHA-2 (Secure Hash Algorithm 2)

미국 국가안보국(NSA)가 설계한 암호화 해시 함수들의 집합.  
SHA-224, SHA-256, SHA-384, SHA-512를 통칭한 이름이다. SHA-n 은 해시값의 크기를 의미하며, 256, 224는 내부 상태크기가 256, 512과 384는 내부 상태크기가 512이다.

##### SHA-256

SHA-256은 미국의 국립표준기술연구소(NIST; National Institute of Standards and Technology)에 의해 공표된 표준 해시 알고리즘인 SHA-2 계열 중 하나이다.