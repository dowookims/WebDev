# Quest 14. Hello, MySQL

## 1. What is RDBMS

### 1.0 What is Database

일반적으로 컴퓨터 시스템 내 전자 방식으로 저장된 구조화된 정보 또는 데이터의 조직적 집합을 의미한다. 데이터 베이스는 데이터베이스 관리 시스템 (DBMS)에 의해 제어되며, 데이터와 DBMS는 연관된 어플리케이션과 함께 `데이터 베이스 시스템` 또는 `데이터베이스`라고 통칭된다.

현재 운용되는 가장 공통적인 유형의 데이터베이스(관계형 데이터 베이스, RDBMS) 내에 데이터는 일련의 표 안에 행과 열로 모델링 되는데 이는 프로세싱과 데이터 쿼리 작업을 더 효율적으로 실행하기 위함이다. 이로써 데이터는 쉽게 액세스, 관리, 수정, 업데이트, 제어, 체계화 될 수 있다. 대부분의 데이터베이스는 데이터 작성 및 쿼리 작업을 위해 SQL을 사용한다.

### 1.1 Why Use DataBase

* 대량의 데이터 중에서 필요한 것을 빨리 반환할 수 있다.
  * 데이터 베이스는 효율적으로 데이터 구조를 관리하는 것을 목적으로 한다.
  * 대량의 데이터에서 효율적인 탐색을 위해 검색 알고리즘 및 인덱스와 같은 데이터 구조로 레코드를 관리한다.
  
* 데이터를 안전하게 저장하기 위해 필요하다
  * 인메모리 데이터는 휘발성이 강하여, 빠른접근은 가능하지만 오류시 복구에 큰 차질을 빚는다.
  * 검색 뿐만 아니라 저장, 복구, 보안등을 효율적으로 관리 할 수 있게 한다.

* 병렬성 제어를 용이하게 해준다.
  * 배타 제어의 범위를 손쉽게 설정 할 수 있다.
  * 상호 배제를 하는데 용이하다.

* 데이터의 무결성을 보장한다.
  * 제약 조건 및 영속성 있는 ID 부여 및 다양한 방법으로 데이터의 무결성을 보장한다.

### 1.2 What is MySQL

세계에서 가장 많이 쓰이는 오픈 소스의 관계형 데이터베이스 관리 시스템(RDBMS)이다.  
다중 스레드, 다중 사용자 형식의 구조질의어 형식의 데이터베이스 관리 시스템으로서 오라클이 관리 및 지원하고 있으며 이중 라이선스가 적용된다.

#### 1.2.1 MySQL Engines

데이터 베이스를 어떻게 구현하여 사용 할 지는 데이터 베이스의 용도에 따라 달라진다. MySQL에서는 다양한 레코드 처리 방법을 제공하고 있기에 용도에 맞는 것을 선택할 수 있는 아키텍처를 채용하고 있다. 이것들을 스토리지 엔진이라고 한다.  
 스토리지 엔진의 선택은 테이블 단위로 할 수 있다. 따라서 어플리케이션에서 여러 스토리지 엔진을 혼합할 수 있다.

##### InnoDB

InnoDB는 높은 신뢰성과 고성능 사이의 밸런스를 가지고 있는 범용 스토리지 엔진이다.
MySQL 8.0 버전에서 MyISAM 을 제치고 MySQL 테이블의 default type으로 지정되었다.

InnoDB 테이블은 Primary key를 기반으로 쿼리를 최적화하기 위해 디스크의 데이터를 할당한다. 각 InnoDB 테이블에는 데이터를 정리하여 Primary Key 조회를 위한 I/O를 최소화하는 clustered index라는 primary key index가 있다.

* Transactional-safe (ACID)

  * Atomicity  
    트랜잭션 작업이 부분적으로 실행되거나 중단되지 않는 것을 보장 (All or Nothing)
  * Consistency  
    트랜잭션 작업이 시작되지 전에 데이터베이스 상태가 일관된 상태였다면 트랜잭션 작업이 종료된 후에도 일관성 있는 데이터 베이스 상태를 유지해아한다.
  * Isolation  
    트랜잭션 작업 수행 중에는 다른 트랜잭션에 영향을 주어서도 안되고, 다른 트랜잭션들에 의해 간섭을 받아서도 안 된다
  * Durability  
    일련의 데이터 조작(트렌젝션 조작)을 완료 하고 완료 통지를 사용자가 받는 시점에서 그 조작이 영구적이 되어 그 결과를 잃지 않는 것을 나타낸다  
    commit, rollback, recovery, row-level locking, foreign key를 지원한다.

* 제약조건, FK, PK 등으로 인해 데이터 무결성에 대한 보장이 된다.
* row level lock(행 단위)을 하기에, 쓰기, 변경 작업이 빠르다.
* 데이터 모델 디자인에 많은 시간이 필요하다.
* Full text search를 지원한다.
* ordering 가능

##### MyISAM

* non-transactional-safe 테이블을 관리한다.
* non-acid compliant
* 데이터 무결성이 보장되지 않는다.
* Full text index를 통한 search를 지원한다.
* Table level lock을 사용하기에 쓰기 작업에서 속도가 느리다.
* 읽기 위주 작업에 주로 사용된다.
* 한번에 대량의 데이터를 입력하는 배치성 테이블에 적합하다.

##### Memory

* Memory storage engine (known as HEAP)은 콘텐츠들을 메모리에 저장하는 특수 목적의 테이블을 생성한다. 이 테이블은 임시 작업 영역 또는 다른 테이블에서 가져온 데이터의 읽기 전용 캐시로만 사용한다.

##### CSV

* comma-separated values format을 사용하는 텍스트 파일을 저장할 때 사용하는 스토리지 엔진.

##### Archive

* 인덱싱되지 않은 대량의 데이터를 매우 작은 공간에 저장하는 특수 목적 테이블을 생성한다.

##### Etc

* Merge
* Blackhole
* Federated

#### 1.2.2 MySQL Data Type

##### 문자열

* CHAR : `CHAR(n)` 으로 스트링 데이터 타입을 지정 할 수 있다.  
`n <= 65535`  
`n`만큼의 메모리를 지정하기 때문에, 이 데이터 타입을 쓰는 변수가 n 만큼의 크기를 갖지 않더라도 공백으로 빈 칸을 채운다.  
해당 변수의 크기를 줄이는 작업이 없기 때문에 varchar보다 오버헤드가 적게든다.

* VARCHAR : VARiable length CHARacter string으로, `varchar(n)`로 스트링 데이터 타입을 지정 할 수 있다.  
`n <= 255`  
`char`와 다르게, 지정한 크기보다 작은 string의 경우 할당된 n만큼 값을 차지하는게 아니라, 그 string의 크기 만큼 메모리를 차지한다. 그렇기에 char보다 overhead를 더 사용한다.

* TEXT : 필드의 기본 값(default)를 가질 수 없으며, TEXT를 인덱싱 할 때 `n`을 정의하는데, 이 `n`은 처음 `n`개의 문자만 인덱스 할 수 있음을 의미한다. 그렇기에, 필드 전체를 검색하는 로직이 있는 경우 `TEXT` 타입보다 `CHAR` 또는 `VARCHAR`를 사용하는게 더 나으며, 필드 앞에 몇 개의 글자만 검색하는 경우에는 `TEXT`를 사용하는 것도 좋다.

  * TINYTEXT(n) : 최대 n (<= 255)
  * TEXT(n) : 최대 n (<= 65535)
  * MEDIUMTEXT(n) : 최대 n (<= 16777215)
  * LONGTEXT(n) : 최대 n (<= 4294967295)

```text
특정 텍스트 값이 저장 될 때, 그 해당 데이터의 텍스트 길이의 유동 폭이 크고, 메모리 관리가 중요 할 경우  
varchar를 쓰는게 더 효율적이고, 텍스트 길이의 유동 폭이 적고, 빠른 읽기 작업이 필요 할 경우 char를 쓰는게 더 나은 사용이다.
```

##### Binary 형

* BINARY : `BINARY(n)` 일반 텍스트와 관련 없는 문자의 전체 바이트를 저장하는데 사용한다.  
GIF와 같은 이미지를 저장하는데 사용되기도 하며, `n <= 255` 이다.

* VARBINARY : `BINARY`의 variable length를 가질 수 있는 값으로 최대 `n <= 65535` 크기의 값을 가질 수 있다.

* BLOB : Binary Large Object. 크기가 65535 바이트를 넘는 바이너리 데이터에 가장 유용하며, `BINARY`와 다른점은 기본 값을 가질 수 없다는 것이다.
  * TINYBLOB(n) : 최대 n (<= 255)
  * BLOB(n) : 최대 n (<= 65535)
  * MEDIUMBLOB(n) : 최대 n (<= 16777215)
  * LONGBLOB(n) : 최대 n (<= 4294967295)

##### 숫자형

float을 제외한 모든 수는 `signed`와 `unsigned`를 가지고 있다.
| datatype | byte | min value(signed / unsigned) | max value(signed / unsgined) |
|----------|------|------------------------------|------------------------------|
| TINYINT  |  1   | -128 / 0 | 127 / 255 |
| SMALLINT | 2 | -32768 / 0 | 32767 / 65535 |
| MEDIUMINT | 3 | -8388608 / 0 | 8388607 / 16777215 |
| INT(INTEGER) | 4 | -2^31 / 0 | 2^31 -1 / 2^32-1 |
| BIGINT | 8 | -2^63 / 0 | 2^63 + 1 / 2^64 - 1 |
| FLOAT | 4 | 3.4E-38(-3.4*10^38) ~ 3.4E+38(3.4*10^38) |
| DOUBLE(REAL) | 8 | 1.79E-308(-1.79*10^308) ~ 1.79E+308(1.79*10^308) |

### 1.3 What is Indexing

데이터 베이스에서 원하는 데이터를 검색하기 위해서 완전 탐색을 진행하게 되면 O(N) 의 복잡도를 가진다.  
이런 선형 검색의 경우 데이터 베이스 테이블의 자료수에 영향을 받기 때문에 이보다 더 효율적인 알고리즘으로 검색을 처리해야 할 필요성이 있다. 이 때 사용되는 것이 Index 이다.

인덱스는 각각의 인덱스마다 파일 상의 시작 위치를 기록한 파일을 만듬으로써 고속으로 검색을 가능하게 한다.  
인덱스 항목이 (key, byte location) 일 경우, 고정 길이 포맷으로 대응할 수 있는데, 이는 특정한 로직으로 이를 고정 포맷으로 적용하게 만드는 것이다.  

#### 1.3.1 Hash

실제 데이터베이스의 구현에서 키 값을 그대로 관리하는 게 아니라, 키 값을 해쉬 함수에 대입 해, 해쉬 값과 값의 쌍을 갖는 구조가 자주 사용되고 있다. 이런 인덱스를 `Hash Index`라고 한다.

해시 값은 문자열 길이에 상관없이 동일한 크기이므로 고정 길이 포맷으로 대응 할 수 있으며, 해시 계산 비용도 데이터 양에 의존하지 않기에 데이터 양이 늘어도 계산량은 변경되지 않는다.

데이터량이 많아지다보면 해시함수는 해시값의 개수보다 많은 키 값을 해시값으로 변환 하게 되고, 해시함수가 서로 다른 두개의 키에 동일한 해시 값을 내는 `해시 충돌(collision)`이 발생할 수 있다.

또한 해시는 하나의 항목을 검색하는데 효율적이나, 범위 검색을 통한 대량의 데이터 반환 및 소팅에 큰 도움이 되지 않는다. 이를 해결하기 위해 `B+ Tree` Index가 존재한다.

#### 1.3.2 B+ Tree

`Root` + `Branches` + `Leaf`로 이루어진 Tree구조로 된 Index.

데이터 검색을 위해 `Root` => `Branch` => `Leaf` 순으로 이동하여 조회한다.

* 레코드 수가 적으면 `Root`가 `Branch`를 겸하며, `Root`와 `Leaf` 밖에 없는 패턴도 존재한다.

* 레코드 수가 많으면  브랜치 아래 브랜치가 들어가는 계층 구조가 구성될 것이다.

`이진 트리`의 경우 레코드 수당 탐색에 필요한 복잡도가 밑이 2인 로그 함수를 따른다. 그러나 B+ Tree의 경우 분기를 M개로 하여 액세스 횟수를 적게 함으로, 밑이 m인 로그 함수를 구현함으로써 더 효율적으로 동작 할 수 있다.

`B+ Tree, B- Tree`의 저장 및 선택에 대해서도 공부 할 것.

### 1.4 데이터베이스 정규화

데이터베이스를 잘못 설계하면 불필요한 데이터 중복으로 인한 공간낭비를 넘어, 부작용을 초래 할 수 있다. 이러한 부작용을 이상(Anomaly)이라고 하는데, 이상 현상의 종류로 삽입 이상, 갱신 이상, 삭제 이상이 있다.

이런 부작용을 줄이고자 관계형 데이터베이스의 설계에서 중복을 최소화하게 데이터를 구조화 하는 프로세스를 정규화라고 한다.

이론적으로는, 함수적 종속성을 이용하여 연관성 있는 속성들을 분류하고, 각 릴레이션들에서 이상 현상이 생기지 않도록 하는 과정을 말한다.

정규화 된 정도를 정규형(Normal Form) 으로 표현하는데, 정규형에는 1NF, 2NF, 3NF, BCNF, 4NF, 5NF, 6NF 가 있다.

#### 1.4.0 정규화 과정

##### 제 1 정규형 (1NF, First Normal Form)

릴레이션에 속한 모든 속성의 도메인이 원자 값으로만 구성되어 있으면 **제1 정규형**에 속한다.

관계형 데이터베이스의 릴레이션은 모든 속성이 원자 값을 가지는 특성이 있기 때문에, 최소 제 1 정규형을 만족해야 릴레이션이 될 자격이 존재한다.

| STUDENT_ID | COURSE_ID | GRADE | STUDENT_NAME |
| ---------- | --------- | ----- | ------------ |
| 2011010504 | SP100001, SP100002, SP100003 | A+, A+, A+ | 김도우 |

위와 같은 형태의 릴레이션은 제1 정규형을 만족하지 않는다. 이를 제1 정규형을 만족하게 하기 위해서는

| STUDENT_ID | COURSE_ID | GRADE | STUDENT_NAME |
| ---------- | --------- | ----- | ------------ |
| 2011010504 | SP100001  |  A+   | 김도우         |
| 2011010504 | SP100002  |  A+   | 김도우         |
| 2011010504 | SP100003  |  A+   | 김도우         |

과 같이 되어야 한다.

##### 제 2 정규형 (2NF, Second Normal Form)

제 1 정규형만 만족시키는 릴레이션에서 부분 함수 종속성을 가지게 되는 경우 `삽입 이상`, `갱신 이상`, `삭제 이상`이 나타나게 된다. 그렇기에, 제 1 정규형에 속하면서 기본키가 아닌 모든 속성이 기본키에 완전 함수 종속을 만족 시키면 `제 2 정규형` 이라고 한다.

| STUDENT_ID | COURSE_ID | GRADE | STUDENT_NAME | major |tuition |
| ---------- | --------- | ----- | ------------ | ----- |------- |
| 2011010504 | SP100001  |  A+   | 김도우         | PSYCHOLOGY | 1732k ₩|
| 2011010504 | SP100002  |  A+   | 김도우         | PSYCHOLOGY | 1732k ₩|
| 2011010505 | SP100002  |  A+   | 김도우         | PSYCHOLOGY | 1732k ₩|
| 2011010532 | SP100002  |  D0   | 프로이드         | PSYCHOLOGY | 1732k ₩|
| 2011020324 | HP100003  |  A+   | 스펀지밥         | PHILOSOPHY | 1687k ₩|
| 2011030662 | NM100003  |  A+   | 무민         | MATHEMATICS | 2124k ₩|
| 2011030551 | NB100003  |  A+   | 베인         | BIOLOGY | 2124k ₩|
| 2011056589 | EN100003  |  A+   | 문도         | NANO | 2572k ₩|

위 릴레이션의 함수적 종속은 다음과 같은데

* { 학번, 과목코드 } => 성적
* { 학번, 과목코드 } => 이름
* { 학번, 과목코드 } => 전공
* { 학번, 과목코드 } => 등록금
* 학번 -> 전공
* 학번 -> 등록금
* 전공 -> 등록금

현재 학번-> 전공, 학번 -> 등록금 두개의 부분 함수 종속성을 가지고 있다. 이를 제거해 주는 것을 제2정규화라고 한다.

`학번`, `전공`, `등록금` 속성을 가지는 `학생 릴레이션`과 `학번`, `과목코드`, `성적` 속성을 가지는 `성적 릴레이션` 둘로 나누어 주면 부분 함수 종속성을 제거할 수 있다.

`학번->학부 함수종속성` 으로 볼때, 학번만으로 학부에 대한 결정을 지을 수 있다는 말이다.  
그러나 현재 기본키가 학번, 과목코드로 이루어져 있기 때문에 학번만으로 학부에 대한 결정을 지을 수 있다는 게 의미가 없어진다.  
그래서 이를 가능하도록 해주는 과정이 부분 함수 종속성을 제거하는 제2정규화 과정이다.

여기서 학부->등록금 이라는 함수적 종속성은 부분 함수 종속성이 아니다.  
X -> Y 라는 함수적 종속성에서 부분 함수 종속성, 완전 함수 종속성을 따질 때 결정자 X가 반드시 기본키나 후보키에 속할 필요는 없으므로 현재 학부->등록금 의 함수 종속은 하나의 완전 함수 종속이라고 볼 수 있다.

* 학생 릴레이션

| STUDENT_ID | STUDENT_NAME | major |tuition |
| ---------- | ------------ | ----- |------- |
| 2011010504 | 김도우        | PSYCHOLOGY | 1732k ₩|
| 2011010504 | 김도우        | PSYCHOLOGY | 1732k ₩|
| 2011010505 | 김도우        | PSYCHOLOGY | 1732k ₩|
| 2011010532 | 프로이드       | PSYCHOLOGY | 1732k ₩|
| 2011020324 | 스펀지밥       | PHILOSOPHY | 1687k ₩|
| 2011030662 | 무민          | MATHEMATICS | 2124k ₩|
| 2011030551 | 베인          | BIOLOGY | 2124k ₩|
| 2011056589 | 문도          | NANO | 2572k ₩|

* 성적 릴레이션

| STUDENT_ID |COURSE_ID | GRADE |
| ---------- | ---------| ----- |
| 2011010504 |SP100001  |  A+   |
| 2011010504 |SP100002  |  A+   |
| 2011010505 |SP100002  |  A+   |
| 2011010532 |SP100002  |  D0   |
| 2011020324 |HP100003  |  A+   |
| 2011030662 |NM100003  |  A+   |
| 2011030551 |NB100003  |  A+   |
| 2011056589 |EN100003  |  A+   |

릴레이션이 둘로 분해되면서 학부와 등록금에 대한 중복항목이 제거되었다.  
정규화 과정에서 주의할 점은 정규화를 통해 분해된 릴레이션들이 조인을 통해 원래의 구조로 복원될 수 있어야 한다는 것이다.  
두 릴레이션 모두 제1정규형에 속하고, 기본키가 아닌 모든 속성이 기본키에 완전 함수 종속되므로 제2정규형을 만족한다.

그러나 제 2 정규형을 만족한다고 해서 이상 현상이 없어지는 것은 아니다.


**삽입 이상**

새로운 학부가 생기는 경우 등록된 학생(학번)이 없으면 학번 속성이 NULL이 되므로 삽입 할 수 없다.

**갱신 이상**  
심리학과 등록금이 오르는 경우 20110105nm 둘 모두 바꾸어 주지 않으면 데이터 불일치 문제 발생

**삭제 이상**  
2011030662 무민 학생이 삭제되는 경우 수학과 데이터가 함께 사라진다.

이런 이상이 발생하는 이유는, `이행적 함수 종속`이 존재하기 때문이고, 이를 없애주는 과정이 제 3 정규화이다.

##### 제 3 정규형 (3NF, Third Normal Form)

제 3 정규형에 속하면서, 기본키가 아닌 모든 속성이 기본키에 이행적 함수 종속이 되지 않으면 제 3 정규형이다.

위 테이블에서 함수적 종속성이

```
학부 -> 학번
학부 -> 등록금
학번 -> 등록금
```

이를 분리 할 수 있는데, X -> Y, Y -> Z 함수적 종속 관계로 X->Z의 이행적 함수 종속 관계가 나타나면 [X, Y], [Y, Z] 두 릴레이션으로 분해한다. 즉,

* 학생 테이블  

| STUDENT_ID | NAME | MAJOR |
| ---- | ---- | ---- |
|  | | |

* 전공 테이블

| MAJOR | TUITION |
| ----- | ------- |
| | |

제 3 정규형을 만족한다 하더라도 이상 현상이 없어지는 건 아닌데, 후보키를 여러개 가지고 있는 릴레이션에서는 제3정규형을 만족하더라도 이상현상이 생길 수 있다.

이를 해결하기 위한 정규형이 보이스-코드 정규형 (BCNF; Boyce-Codd Normal Form)이다. 제3정규형보다 조금 더 엄격한 제약조건을 가지기 때문에 Strong 3NF 라고도 한다.

##### BCNF

X -> Y는 trivial functional dependency 이거나, X는 릴레이션R의 슈퍼키 일 조건을 만족 시키면 이 릴레이션은 BCNF 이다.

trivial FD는 Y가 X의 부분집합인 경우를 말한다. 상식 적으로 이해가 되는 서브셋인 경우, A -> A이거나 AB -> A인 경우이다.

#### 1.4.1 키

##### 슈퍼키

테이블에서 각 행을 유일하게 식별할 수 있는 하나 또는 그 이상의 속성들의 집합. 슈퍼키는 유일성(Unique)만 만족하면 슈퍼키가 될 수 있다.

##### 후보키

각 행을 유일하게 식별할 수 있는 최소한의 속성들의 집합이다. 후보키는 기본키가 될 수 있는 후보들이며, 유일성과 최소성을 동시에 만족해야 한다.

##### 기본키 (Primary Key)

후보키들 중에서 하나를 선택한 키로, 최소성과 유일성을 만족하는 속성이며, 테이블에서 기본키는 오적 1개만 지정 할 수 있다.

PK는 테이블 안에서 유일하게 각 행들을 구별할 때 쓰고, NULL 값을 가질 수 없으며 중복된 값을 가질 수 없다.

##### 대체키 (Alternate Key)

후보키가 두 개 이상일 때, 어느 하나를 기본키로 지정하고, 남은 후보키를 대체키라고 한다.

##### 외래 키 (Foreign Key)

테이블이 다른 테이블의 데이터를 참조하여 테이블간 관계를 연결하는 것이다.

* 참조 될 테이블이 먼저 만들어지고, 참조하는 테이블에 값이 입력되어야 하며, 참조될 열의 값은 참조될 테이블에서 기본키로 설정되어 있어야 한다.

* 즉, 참조되는 부모테이블이 먼저 생성된 뒤 데이터를 넣고, 참조하는 자식 테이블이 다음에 생겨야 한다.
* 데이터의 무결성을 위해 외래키 제약조건을 걸기도 하는데, 부모 테이블이 먼저 삭제되면 자식테이블은 참조하는 것이 없어지는데 이는 데이터 무결성 원칙을 깨트린다. 이를 방지 하기 위해 `외래키 제약 조건`을 걸어둔다.



#### 1.4.2 이상

##### 삽입 이상 (Insertion Anomaly)

새 데이터를 삽입하기 위해 불필요한 데이터도 함께 삽입해야 하는 문제를 **삽입 이상** 이라고 한다.

##### 갱신 이상 (Update Anomaly)

중복 튜플 중 일부만 변경하여 데이터가 불일치하게 되는 모순의 문제를 **갱신 이상** 이라고 한다.

##### 삭제 이상 (Deletion Anomaly)

튜플을 삭제하면 필요한 데이터까지 함께 삭제되는 데이터 손실의 문제를 **삭제 이상** 이라고 한다.

#### 1.4.2 함수적 종속성

함수적 종속성은 다음과 같이 표현한다.

`X => Y`
* X는 결정자, Y는 종속자라고 한다.
* X가 Y를 함수적으로 결정한다.
* Y가 X에 함수적으로 종속되어 있다.

| STUDENT_ID | COURSE_ID | GRADE | STUDENT_NM |
| ---------- | --------- | ----- | ---------- |
| 2011010504 | SP1000001 | A+ | 김도우 |
| 2011010537 | SP1000006 | A+ | 황순필 |
| 2011010523 | SP1000012 | B0 | 오도학 |
| 2011010536 | SP1000013 | A0 | 최재홍 |

위 테이블에서 함수적 종속성은 아래와 같다.

```
학번 -> 이름
{ 학번, 과목코드 } -> 성적
{ 학번, 과목코드 } -> 이름
```

이름의 경우 해당하는 함수적 종속성이 두개이다. 여기서 `부분 함수적 종속`과 `완전 함수적 종속`을 구분 할 수 있다.

##### 부분 함수적 종속 (Partial Functional Dependency)

`속성 집합Y가 속성 집합 X의 전체가 아닌 일부분에도 함수적으로 종속됨을 의미한다.`

위 테이블에서 `학생 이름`은 속성 집합 Y이고, {학번, 과목코드}가 속성 집합 X인 상태일 때, 이름은 {학번, 과목코드}에도 함수적으로 종속되며 X의 일부인 학번에도 종속된다.

##### 완전 함수적 종속 (Full Functional Dependency)

`속성 집합Y가 속성 집합 X의 전체에 대해서만 함수적으로 종속된 경우를 의미한다.`

위 테이블에서 `성적`은 속성 집합 Y이고, `{학번, 과목코드}`기 속성 집합 X일 때, 성적은 속성 집합 X의 어떤 부분 집합에도 함수적으로 종속되어 있지 않고 오직 `속성 집합 X`에만 종속 될 경우를 말한다.

일반적으로 함수적 종속성의 경우 완전 함수 종속을 의미한다.

##### 이행적 함수 종속 (Transitive Functional Dependency)

삼단 논법과 같은 관계를 가진 함수 종속이다. X, Y, Z에 대해  

X - > Y

Y - > Z 이면

X -> Z 가 성립한다.

이를 Z가 X에 이행적으로 함수 종속 되었다고 한다.

[데이터베이스 정규화 - 이상현상 & 함수적 종속성](https://yaboong.github.io/database/2018/03/09/database-anomaly-and-functional-dependency/)

## 2. SQL Query

### 2.1 Create

```SQL
INSERT INTO <tablename> (column1,column2,….)
 
VALUES (value1_1,value1_2,….),
(value2_1, value2_2, ...)
...
(value_n_1, valuen_2, ...);
```

### 2.2 Read

```SQL
SELECT (column1, column2 ,...) FROM <TableName>
```

```SQL
SELECT * FROM <TableName>
```

### 2.3 Update

```SQL
UPDATE <TableName>
SET Column1=Value1, Column2=Value2,…
WHERE <Expression>
```

### 2.4 Delete

```SQL
DELETE FROM <TableName>
WHERE <Expression>
```

## 3. Hashing

`Hashing`은 파일에서 고정 크기 비트 문자열 값을 계산하는 알고리즘이다. 파일은 기본적으로 데이터 블록을 포함한다. Hashing은 이 데이터를 원래의 문자열을 나타내는 훨씬 짧은 고정 길이 값 또는 키로 변환한다. 해시 값은 해당 파일 내의 모든 것을 증류한 요약본으로 간주할 수 있다.

Hashing이란 기존 값에 수학적 공식을 도입하여 값을 |0-9|, |a-f|로 변환하여 난독화 하게 만드는 것을 의미한다.  
난독화 하는 방법들은 다양한데, 이 방법을 Hash Function이라 하며, Hash function에는 다양한 종류가 존재한다.

해시 함수의 특징으로, 같은 입력값이라면 같은 출력 값을 보장한다는 것이다. 이는 결정론적 알고리즘이라고도 한다.

Hashing을 하는 이유는 다양하다. 보안되어야 할 값을 난독화 하기도 하고, 어떤 변화가 일어 났을 때 그 변화를 손쉽게 파악하기도 하며, 두 파일이 같은지 검사하는 등 다양한 범위에서 사용된다.

*salt* : `rainbow table`에 특정 값들을 저장해 놓고, 관련된 해시를 저장해 두면 보안상 문제가 발생한다. 그렇기에 기존 값에 `salt`라는 값을 추가하여 해커들 또는 `rainbow table`에서 저장 한 값과 다른 값을 도출해 내어 해쉬 함수의 보안을 더 강화하는 값이다.

### 3.1 Hashing Algorithm

SHA-256의 경우 해시 대상 메시지를 전처리하는 단계와 전처리된 메시지를 바탕으로 해시를 계산하는 단계로 나뉜다.

#### 메시지 전처리

SHA-256을 적용해야 할 데이터를 `메시지`라고 한다. 이때 메시지 bit의 길이가 512 배수가 되도록 padding을 추가하는 것이 전처리 단계에서 수행하는 작업이다.

1. 원본 메시지의 바로 뒤에 비트 '1'을 추가한다.
2. 메시지의 길이가 512의 배수가 되도록 메시지에 0을 추가한다.
3. 메시지의 마지막 64bit에는 원본 메시지의 bit 길이를 적는다.

#### 전처리된 메시지 해싱

메시지 전처리가 끝나면 메시지의 bit 길이는 512의 배수 형태가 된다. 이 전처리된 메시지를 512bit 단위로 쪼개어 여러개의 chunk를 만들고, 이 chunk를 순회하며 특정 연산을 수행하여 최종적인 hash값을 계산해 낸다.

[SHA-256구현](https://www.secmem.org/blog/2019/07/21/sha256/)

### 3.2 Types of Hash

#### MD5 (Message Digest Algorithm 5)

128bit 암호화 해시 함수이며, RFC 1321로 지정되었으며 프로그램이나 파일이 원본 그대로인지 확인하는 무결성 검사 등에 사용된다. MD5의 설계상 결함과 `Rainbow Table`에 의해 쉽게 뚫리고, `hash collision`의 발생등으로 인해 보안 관련 용도로 사용하는 것은 권장되지 않는다.

* 32개의 문자(16진수 - 4비트) 로 해쉬 결과의 길이가 128 비트이다.

#### SHA-2 (Secure Hash Algorithm 2)

미국 국가안보국(NSA)가 설계한 암호화 해시 함수들의 집합.  
SHA-224, SHA-256, SHA-384, SHA-512를 통칭한 이름이다. SHA-n 은 해시값의 크기를 의미하며, 256, 224는 내부 상태크기가 256, 512과 384는 내부 상태크기가 512이다.

##### SHA-256

SHA-256은 미국의 국립표준기술연구소(NIST; National Institute of Standards and Technology)에 의해 공표된 표준 해시 알고리즘인 SHA-2 계열 중 하나이다.

## CheckList

* RDBMS에 길이를 알 수 없는 배열을 저장하려면 어떻게 설계해야 할까요?
  1. MySQL 기준으로 배열 타입이 존재하지 않기 때문에 이를 `JSON.stringify()`를 활용하여 String으로 만들고, 이를 String type을 활용(VARCHAR, TEXT)해 저장
  2. 배열 데이터를 BLOB으로 만들고, `BLOB`등 이진 데이터로 만들어 저장한다.

* DB에 사용자의 암호를 평문으로 저장하지 않고도 사용자의 암호를 인증하는 것이 가능한 이유는 무엇일까요?
  * 해쉬 함수의 특징인 결정론적 알고리즘 때문. 같은 입력값이면 같은 출력값을 보장하기 때문이다.
  * 클라이언트에서 사용자 아이디와 비밀번호를 받아서, 암호화 하는 방법에 대해 고민해 보았습니다. 그리고 제가 생각한 방법은 다음과 같습니다.
    * 클라이언트 측에서 서버로 요청을 보낼 때, 이를 서버가 받을 때에는 양방향 암호화를 사용해야 할 것 같습니다.
        1. 클라이언트에서 사용자의 아이디와 비밀번호를 보낼 때, 요청을 탈취 했을 때 평문으로 보내는 경우는 위험한 행동이라 생각합니다. 그렇기에 암호화를 해줘야 합니다.
        2. 여기서, 클라이언트에서 단방향 암호화를 했다면, 이를 서버에서 해석 할 수 없을 뿐 더러, 이 자체를 데이터베이스에 저장하여 사용 할 때에도 문제가 발 생할 수 있을 것 같습니다.
        3. 그렇기에, 클라이언트에서 서버로 보낼 때에는 양방향 암호와 알고리즘을 사용하되, 비대칭키 방식으로 암호화를 진행해야 할 것 같습니다.
        4. 서버에서는 클라이언트에서 받은 암호화된 사용자의 아이디와 비밀번호를 받고, 이를 서버의 비밀키를 통해 해석하고, 해석한 메시지를 다시 단방향 암호화를 통해 데이터베이스의 값과 조회 / 저장을 진행해야 보안에 좋을 것 같습니다.
        5. 여기서 궁금한 것은 이런 방식을 활용할 때 복호화 및 암호화시 걸리는 속도의 문제입니다. 대규모 어플리케이션의 경우 서버에서 이를 처리하는데 걸리는 속도가 어떻게 되는지에 대해서는 아직 답을 못찾았습니다.

[암호화 양방향, 단방향, 공개키(비댕칭키), 비공개키(대칭키) 개념/분류 알고리즘 정리](https://javaplant.tistory.com/26)

[안전한 패스워드 저장](https://d2.naver.com/helloworld/318732)

[네이버 애플리케이션의 전자 서명 원리](https://d2.naver.com/helloworld/744920)

### Quest

```SQL
create table User (
    userid VARCHAR(50) PRIMARY KEY,
    username VARCHAR(50) UNIQUE NOT NULL,
    password VARCHAR(50) NOT NULL,
    UNIQUE INDEX idx_userid (userid),
    UNIQUE INDEX idx_username (username)
);

create table Post (
    id INT PRIMARY KEY AUTO_INCREMENT,
    title VARCHAR(50) NOT NULL,
    text TEXT,
    userid varchar(50),
    FOREIGN KEY (userid) REFERENCES User (userid),
    UNIQUE INDEX idx_id (id)
);

create table UserWorkingState (
    userid VARCHAR(50) UNIQUE NOT NULL,
    tabs TEXT,
    selectedTab TEXT,
    cursorLen INT,
    FOREIGN KEY (userid) REFERENCES User (userid)
);
```
